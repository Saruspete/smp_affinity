#!/usr/bin/perl

# #############################################################################
# smp_affinity.pl - Utility to get/set affinities of IRQs and Processes
#
# - Display CPU affinity for IRQ & Processes
# - Set distributed patterns from keywords
#
# Author : Adrien Mahieux <adrien.mahieux@gmail.com>
#
# #############################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# #############################################################################
# Notes:
#
# I tried to use Math::BigInt, but it's way too slow for the calculations needed
# I don't want to use Sys::Hwloc::Bitmap, is it's non standard and only working
# for existing process.
# So I embed my own Bitmask class, that stores big masks as a serial of
# independant 32 or 64bits numbers.
# #############################################################################


use strict;
use warnings;

use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case gnu_compat bundling auto_help);
use Pod::Usage;
use List::Util qw(max);


my $opt_show_help;
my $opt_show_sep = ' ';

my $opt_check_health;

my $opt_show_onlymod;
my $opt_show_onlydef;
my $opt_show_pctcpu;
my $opt_show_pctmem;
my $opt_show_realtime;
my $opt_show_stats;
my $opt_show_kthreads;
my $opt_show_quiet;
my $opt_show_count;
# TODO: Add filtering
my $opt_show_filter;

my @opt_show_listcpu;
my @opt_show_listirq;
my @opt_show_listproc;
my @opt_show_listuser;

my $opt_set_dry;
my @opt_set_listcpu;
my @opt_set_listirq;
my @opt_set_listproc;
my $opt_set_distribute;

my @cpu_schedrt = ('FF','RR');
my $bin_taskset = findbin('taskset');
my $lib_sched = sched_dynload();
my $has_proclist = sched_checkproc();
my $has_ps_etimes = 0;
my $chk_userlisthasregex = 0;
my $has_color = (-t STDOUT) ? 1 : 0;

# System common values
my @cpu_allavail_list = @{cpu_getavail()};
my @cpu_isolated_list = @{cpu_getisolated()};
my @cpu_default_list  = @{cpu_getdefault()};

my $cpu_allavail_mask = Bitmask->new(\@cpu_allavail_list);
my $cpu_isolated_mask = Bitmask->new(\@cpu_isolated_list);
my $cpu_default_mask  = Bitmask->new(\@cpu_default_list);

#my $v = "fafbfa23ff";
#my $test = Bitmask->new($v);
#print " - $v toHexStr : " . Dumper($test->toHexStr());
#print " - $v toList: " . Dumper($test->toList());

# Parse options
GetOptions(
	# Help
	'h|help'            => \$opt_show_help,

	# Display format modifiers
	's|statistics'      => \$opt_show_stats,
	'q|quiet'           => \$opt_show_quiet,
	'c|show-cpus=s'     => \@opt_show_listcpu,
	'color!'            => \$has_color,

	# Display filters
	'd|defined-only'    => \$opt_show_onlydef,
	'k|kernel-threads'  => \$opt_show_kthreads,
	'pctcpu=s'          => \$opt_show_pctcpu,
	'pctmem=s'          => \$opt_show_pctmem,
	'rt|realtime'       => \$opt_show_realtime,
	#'f|filter=s'        => \$opt_show_filter,
	'r|show-count=s'    => \$opt_show_count,
	'i|show-irq=s'      => \@opt_show_listirq,
	'p|show-proc=s'     => \@opt_show_listproc,
	'u|show-user=s'     => \@opt_show_listuser,

	# Set related options
	'm|show-modified'   => \$opt_show_onlymod,
	'dry|pretend'       => \$opt_set_dry,

	# Setting values
	'C|set-cpu=s'       => \@opt_set_listcpu,
	'I|set-irq=s'       => \@opt_set_listirq,
	'P|set-proc=s'      => \@opt_set_listproc,
	'D|distribute=i'    => \$opt_set_distribute,

	'H|health'          => \$opt_check_health,
) or die ('Error while parsing options. Stopping');

pod2usage(-verbose=>2) if $opt_show_help;


my $chr_cpustdon   = "X";
my $chr_cpustdoff  = " ";
my $chr_cpuisolon  = "I";
my $chr_cpuisoloff = " ";

# Use red background to display isolated cores
if ($has_color) {
	$chr_cpuisolon  = "\e[41;1m" . $chr_cpuisolon  . "\e[0m";
	$chr_cpuisoloff = "\e[41;1m" . $chr_cpuisoloff . "\e[0m";
}
# If no color, most likely batch mode, thus provide fixed line length (no space)
else {
	$chr_cpuisoloff = "-";
	$chr_cpustdoff  = ".";
}

# #############################################################################
#
# Main processing
#
# #############################################################################

#
# Pre-checks and command line parsing
#

# IRQs
if (@opt_show_listirq) {
	if ( !irq_available_read() ) {
		print "IRQs check is not available. Are you root ?\n";
		exit(1);
	}
	@opt_show_listirq = @{liststring2list(\@opt_show_listirq)};
}
if (@opt_set_listirq) {
	if ( !irq_available_write() ) {
		print "IRQs management is not available. Are you root ?\n";
		exit(1);
	}
	@opt_set_listirq  = @{liststring2list(\@opt_set_listirq)};
}

# Processes
if (@opt_show_listproc || @opt_set_listproc) {
	if ( !proc_available() ) {
		print "The Process management is not available\n";
		print "Be sure the program 'taskset' is installed on this system\n";
		exit(1);
	}

	@opt_show_listproc  = @{liststring2list(\@opt_show_listproc)};
	@opt_set_listproc   = @{liststring2list(\@opt_set_listproc)};
}


#
# Check conflicting values
#
if ($opt_show_onlymod && (@opt_show_listproc || @opt_show_listirq || @opt_show_listuser || $opt_show_filter || $opt_show_count ) ) {
	print "You can't mix 'show-modified|m' with other filters (-d,-p,-i,-u,-c)\n";
	exit(1);
}

if ($opt_check_health && (@opt_show_listproc || @opt_show_listirq || @opt_set_listproc || @opt_set_listirq ) ) {
	print "You can't mix 'health|H' with other actions (show|set) (-p|-P|-i|-I)\n";
	exit(1);
}

#
# Apply filters
#
foreach my $user (@opt_show_listuser) {
	# If user has non standard chars, assume a regex
	if (! ($user =~ /^[^a-zA-Z0-9_]+$/)) {
		$chk_userlisthasregex = 1;
	}
}

# Only apply show defaults if no set action is requested
if (!@opt_set_listirq  && !@opt_set_listproc &&
    !@opt_show_listirq && !@opt_show_listproc &&
    !$opt_check_health) {

	# Defaults to all process to display
	@opt_show_listproc = 'ALL';
}

# Defaults to all CPUs to display
if (!@opt_show_listcpu) {
	@opt_show_listcpu = @cpu_allavail_list;
}

#
# Process expansion
#
@opt_set_listcpu   = @{liststring2list(\@opt_set_listcpu)};
@opt_show_listcpu  = @{liststring2list(\@opt_show_listcpu)};

# Replace special values by their real listing
@opt_set_listcpu   = @cpu_allavail_list   if (inarray('ALL', @opt_set_listcpu));
@opt_show_listcpu  = @cpu_allavail_list   if (inarray('ALL', @opt_show_listcpu));
@opt_set_listcpu   = @cpu_isolated_list   if (inarray('ISOLATED', @opt_set_listcpu));
@opt_show_listcpu  = @cpu_isolated_list   if (inarray('ISOLATED', @opt_show_listcpu));
@opt_set_listcpu   = @cpu_default_list    if (inarray('NOTISOLATED', @opt_set_listcpu));
@opt_show_listcpu  = @cpu_default_list    if (inarray('NOTISOLATED', @opt_show_listcpu));

# Replace the keyword 'ALL' by PID list
if (inarray('ALL', @opt_set_listproc)) {
	@opt_set_listproc = map { $_->{tid} } @{proc_list()};
}

#
# Check values
#

if (@opt_set_listirq || @opt_set_listproc) {
	if (!@opt_set_listcpu) {
		print "You must specify a list of CPUs to set (-C <cpu-list>)\n";
		exit(1);
	}
}


# Check if all values were correctly expanded
my %checkvars = (
	'-c|--show-cpu'  => \@opt_show_listcpu,
	'-p|--show-proc' => \@opt_show_listproc,
	'-i|--show-irq'  => \@opt_show_listirq,
	'-C|--set-cpu'   => \@opt_set_listcpu,
	'-P|--set-proc'  => \@opt_set_listproc,
	'-I|--set-irq'   => \@opt_set_listirq,
);
my $chk_haserr = 0;
for my $chkopt (keys %checkvars) {
	my $chkvar = $checkvars{$chkopt};
	my @invalid = @{check_listinvalid(@$chkvar)};
	if (@invalid) {
		print("Error: Invalid value(s) for $chkopt: " . join(', ', @invalid)."\n");
		$chk_haserr++;
	}
}
exit(1) if $chk_haserr;

# #############################################################################
#
# Health check
#

# The health will check for:
# IRQs that are:
#   - not on their local numa node
# Process that are:
#   - On a CPUs with 2 different RT classes
#   - with affinity between isolated and standard cores
#   - long running (>5min) and high CPU usage (>50%)
#   - on an isolated cpu with multiple processes
#   - realtime with high CPU usage (>30%) and not on an isolated core

if ($opt_check_health) {

	# Gather info and order it
	my %topo  = %{cpu_gettopology()};
	my %irqs  = %{irq_list()};
	my @procs = @{proc_list()};
	my @errors;
	my @missingirqaffinity;

	# Check for IRQs locality
	IRQCHECK:
	for my $irqnum (keys %irqs) {
		my %irq = %{$irqs{$irqnum}};

		if ($irq{affinity} eq 0) {
			push(@missingirqaffinity, $irqnum);
			next IRQCHECK;
		}

		my @irqaffinity_cpus = @{$irq{affinity}->toList()};
		my $irqaffinity_node = $irq{node};

		# Check only if a NUMA node is defined
		if ($irqaffinity_node ne -1) {

			# Loop on all allowed CPUs
			my $firstCPU;
			for my $cpu (@irqaffinity_cpus) {
				# The first CPU in the list is the most-likely to process INT
				if (!$firstCPU) {
					$firstCPU = $cpu;
				}
				if ($topo{cpu2node}[$cpu] ne $irqaffinity_node) {
					push(@errors, "IRQ '$irqnum' assigned to cpu '$cpu' not in node '$irqaffinity_node'");
				}
			}
		}

		# Check for interrupt on multiple CPUs
		#
	}

	if (@missingirqaffinity) {
		push(@errors, "Missing affinity for IRQs: ".join(",", @missingirqaffinity).". Are you root ?");
	}


	# Check for conflicting scheduling classes
	my @cpusched;
	my @cpuspinning;

	for my $task (@procs) {

		my $pid = $task->{"tid"};

		# Skip kernel threads if not requested
		next if ($task->{ppid} eq "2" && !$opt_show_kthreads);

		# Get affinity for these process
		my $affinity = proc_getaffinity($pid);
		next if !$affinity;

		# Check if we are on an isolated core
		if ($cpu_isolated_mask->isIntersect($affinity)) {

			# If we have isolated AND standard cores
			if ($cpu_default_mask->isIntersect($affinity)) {
				push(@errors, "Process $pid ($task->{comm}) affinity is on both Isolated and non-isolated cores");
			}

			# Process is on isolated core, and consumes a lot of cpu, mark this CPU
			if ($task->{pcpu} > 40) {
				for my $cpu (@{$affinity->toList()}) {
					# Check for already spinning process
					if ($cpuspinning[$cpu] > 0) {
						push(@errors, "Process $pid has affinity on cpu $cpu which is already consumed by process ".join(",", @{$cpuspinning[$cpu]}));
					}
					push(@{$cpuspinning[$cpu]}, $pid);
				}
			}

		}
		# Standard core
		else {
			# Check if process is running for more than 5min (300 sec) and consumed
			# more than 50% cpu
			if ($has_ps_etimes && $task->{pcpu} > 50 && $task->{etimes} > 300) {
				push(@errors, "High CPU usage for long running process $task->{tid} on non-isolated core $task->{psr}");
			}

		}

		# Check if multiple realtime classes
		if (inarray($task->{class}, @cpu_schedrt)) {
			for my $cpu (@{$affinity->toList()}) {
				push(@{$cpusched[$cpu]->{$task->{class}}}, $pid);
			}
		}
	}

	# https://stackoverflow.com/questions/20824920/perl-array-references-and-avoiding-type-of-arg-1-to-keys-must-be-hash-error
	for my $cpuid (0 .. $#cpusched) {
		my %cpudat = %{$cpusched[$cpuid] || {} };

		if (keys(%cpudat) > 1) {
			my $msg = "Multiple RT classes on CPU $cpuid: ";
			for my $cls (sort(keys(%cpudat))) {
				$msg .= "$cls(".join(",", @{$cpudat{$cls}}).") ";
			}
			push(@errors, $msg);
		}
	}

	if (@errors) {
		for my $errmsg (@errors) {
			print "$errmsg\n";
		}
	}
}



# #############################################################################
#
# Set requested values
#

my $cpu_set_mask  = Bitmask->new(\@opt_set_listcpu);

# Reset the display lists when displaying only modified elements
if ($opt_show_onlymod) {
	@opt_show_listproc = ();
	@opt_show_listirq = ();
}

# IRQs
if (@opt_set_listirq) {

	foreach my $irq (@opt_set_listirq) {

		my $irq_affinity_mask = irq_getaffinity($irq);
		# Pretend to change...
		if ($opt_set_dry) {
			# Add to display list only if showing modified
			if ($opt_show_onlymod && ! $irq_affinity_mask->isEqual($cpu_set_mask)) {
				push(@opt_show_listirq, $irq);
				push(@opt_show_listcpu, @opt_set_listcpu);
			}
		}
		# Set if not pretending
		else {
			irq_setaffinity($irq, $cpu_set_mask);
		}
	}
}

# Processes
if (@opt_set_listproc) {

	foreach my $pid (@opt_set_listproc) {

		# Add to display list only if showing modified
		if ($opt_show_onlymod && $cpu_set_mask->isEqual(proc_getaffinity($pid)) ) {
			push(@opt_show_listproc, $pid);
			push(@opt_show_listcpu, @opt_set_listcpu);
		}

		# Pretend to change
		my $chgstr = "affinity '".join(',', @opt_set_listcpu)."' to PID '$pid'";
		if ($opt_set_dry) {
			print "Would have set $chgstr\n";
		}
		# Set if not pretending
		else {
			print "Setting pid $pid to $chgstr\n";
			proc_setaffinity($pid, $cpu_set_mask);
		}
	}
}



# #############################################################################
#
# Display
#

my $cpu_show_mask = Bitmask->new(\@opt_show_listcpu);

# Get some variables
my $term_size = int(qx(/usr/bin/tput cols)) || 80;
my $cpu_count = $#opt_show_listcpu+1;


# Calculations for column sizes
my $col_sep = ' ';
my $col_id  = 6;
my $col_name = 8;
my $col_cpu = $cpu_count * 3; # 3 cols / cpu
# If we have some fields with 3 chars, add them
if (max(@cpu_allavail_list) >= 100) {
	$col_cpu += grep { $_ >= 100 } @opt_show_listcpu;
}

# dyn column = term width -  1st col  - 2nd col     - last col   - 3 cols * 1 char separator
my $col_text = $term_size - ($col_id) - ($col_name) - ($col_cpu) - (3*1) -1;

if ($col_text <= 0) {
	print "Your terminal is not wide enough to display the list for $cpu_count CPUs\n";
	print "You're missing ".abs($col_text)." columns\n";
	exit(1);
}

# lines formaters
#my $head = "%-".($col_id+1+$col_name+1+$col_text+1)."s ";
my $head =	"%-${col_id}s"    . $col_sep .
			"%-${col_name}s"  . $col_sep .
			"%-${col_text}s " . $col_sep;

my $body =	"%-${col_id}.${col_id}s"     . $col_sep .
			"%-${col_name}.${col_name}s" . $col_sep .
			"%-${col_text}.${col_text}s" . $col_sep .
			" %s";


# Show the header if not quiet
if (!$opt_show_quiet && (@opt_show_listproc || @opt_show_listirq) ) {
	# Print the header
	printf($head, "ID", "Owner", "Description");
	foreach my $cpu (@opt_show_listcpu) {
		print(" ") if ($cpu <= 9);
		print("$cpu ");
	}
	print "\n";
}


# Display IRQs
if (@opt_show_listirq) {

	my $irq_default = irq_default();
	my %irq_list = %{irq_list()};
	foreach my $irqnum (sort { $a <=> $b}  keys %irq_list) {
		my $irq = $irq_list{$irqnum};

		# Filter on non-stnadard affinities only (or erroneous)
		next if ($opt_show_onlydef && $irq->{affinity} && $irq->{affinity} eq $irq_default );


		# Filter
		if (inarray('ALL', @opt_show_listirq) || inarray($irq->{irq}, @opt_show_listirq)) {


			# Specific CPU affinity
			if (!$cpu_show_mask->isEqual($cpu_default_mask)) {
				next if ($irq->{affinity} && ! $irq->{affinity}->isIntersect($cpu_show_mask) );
			}

			my $text = $irq->{name};

			if ($opt_show_stats) {
				$text .= "";
			}

			# If we have the real affinity, show it as usual
			if ($irq->{affinity}) {
				printf($body."\n",
						$irq->{irq},
						'',
						$text,
						cpu_dispmask($cpu_show_mask, $irq->{affinity})
					);
			}
			# else, cannot read the affinity. Show "?" instead
			else {
				printf($body."\n",
						$irq->{irq},
						'',
						$text,
						cpu_dispmask_unknown($cpu_show_mask)
					);
			}
		}
	}
}

# Display CPUs
if (@opt_show_listproc) {

	# Order the process list - I bet you love Schwartzian transform :)
	my @proclist =
		map { $_->[2] }
		sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }
		map { [int($_->{pid}), (int($_->{ppid}||0) eq 2)? 0 : ($_->{ppid}||0), $_] }
		@{proc_list()};

	# Walk on each process
	proclist:
	foreach my $proc (@proclist) {

		# Filter on simple user listing
		if (!$chk_userlisthasregex) {
			next if (@opt_show_listuser && ! inarray($proc->{user}, @opt_show_listuser));
		}
		# listing has non standard chars, advanced parsing
		else {
			# List all users.
			# - If we match a negated pattern, skip it directly
			# - If we found at least one non-negated listing, expect user to be listed
			# - If we have only negated patterns, allow all

			# By default, expect no direct listing so allow user
			my $usermustbefound = 0;
			my $userfound = 0;
			foreach my $useralias (@opt_show_listuser) {
				# Need to do a copy, else we modify the source from array
				my $user = $useralias;

				# Negation handling
				my $skiponmatch = 0;
				if (substr($user, 0, 1) eq "!") {
					$user = substr($user, 1);
					$skiponmatch = 1;
				}
				# We have at least one explicit listing (non negated)
				else {
					$usermustbefound = 1;
				}

				# We got a match !
				if ($proc->{user} =~ /^$user$/) {
					# If user matches a negated user, skip it directly
					if ($skiponmatch) {
						next proclist;
					# Mark it as good for now
					}
					else {
						$userfound = 1;
					}
				}
			}

			# skip if we didn't find a match when we should have
			next proclist if (!$userfound && $usermustbefound);
		}

		# Filter on kernel thread (PID: 1=init, 2=kthreadd)
		next if (!$opt_show_kthreads && ($proc->{pid} eq 2 || $proc->{ppid} eq 2));

		if (inarray('ALL', @opt_show_listproc) ||
			inarray($proc->{tid}, @opt_show_listproc) ||
			inarray($proc->{pid}, @opt_show_listproc) ) {

			# Skip elements where we don't have affinity
			my $affinity_mask = proc_getaffinity($proc->{tid}) || next;

			# Filter on non-stnadard affinities only
			if ($opt_show_onlydef) {

				# Default CPU listing
				next if ($affinity_mask->isEqual($cpu_default_mask));

				# Specific CPU affinity, but no CPU we are interested in
				next if ( ! $affinity_mask->isIntersect($cpu_show_mask) );
			}

			# Filter by cpu affinity count
#			if ($opt_show_count) {
#				my $rangeDir = substr($opt_show_count, 0, 1);
#				# Less / More / Exactly
#				next if ($rangeDir eq '-' && $affinity_mask > substr($opt_show_count, 1));
#				next if ($rangeDir eq '+' && $affinity_mask < substr($opt_show_count, 1));
			# TODO: What ?
#				next if (int($opt_show_count) eq $opt_show_count && $affinity_mask != $opt_show_count);
#			}

			# Filter by CPU Usage
			if ($opt_show_pctcpu) {
				my $cpuVal = int($opt_show_pctcpu);
				next if ($cpuVal < 0) && int($proc->{pcpu}) > -$cpuVal;
				next if ($cpuVal >= 0) && int($proc->{pcpu}) < $cpuVal;
			}
			# Filter by memory Usage
			if ($opt_show_pctmem) {
				my $memVal = int($opt_show_pctmem);
				next if ($memVal < 0) && int($proc->{pmem}) > -$memVal;
				next if ($memVal >= 0) && int($proc->{pmem}) < $memVal;
			}
			# Filter by realtime
			if ($opt_show_realtime) {
				next if (!inarray($proc->{class}, @cpu_schedrt));
			}

			my $text = join(' ', @{$proc->{args}});
			# If it's not the thread leader, offset it and change the text
			if (($proc->{tid} != $proc->{pid})) {
				$text = '    ' . $proc->{comm};
			}

			# Add more statistics before
			if ($opt_show_stats) {
				$text = sprintf("%-3s %-2s %-2s %-4s %-4s %-1s", $proc->{class}, $proc->{rtprio} || "-", $proc->{psr}, $proc->{pcpu}, $proc->{pmem}, $proc->{s})." $text";
			}

			# Finally, display
			printf($body."\n",
					$proc->{tid},
					$proc->{user},
					$text,
					cpu_dispmask($cpu_show_mask, $affinity_mask),
				);
		}
	}
}




# #############################################################################
#
# Working subs : The magic happens here
#
# #############################################################################


# Find a binary in $ENV{PATH} and usual paths
sub findbin {
	my $cmd = shift;
	my @paths = split(/:/, $ENV{PATH});
	push(@paths, ('/sbin','/usr/sbin'));
	foreach my $path (@paths) {
		my $b = $path.'/'.$cmd;
		return $b if (-x $b);
	}
	return;
}

# Is an element in an array
sub inarray {
	my $match = shift;
	grep $_ eq $match, @_;
}

sub arrayize {
	my @arrays = @_;
	my @ret;
	foreach $a (@arrays) {
		my $r = ref($a);

		# Scalar
		if ($r eq '') {          @ret = (@ret, ($a));  }
		# Refs
		elsif ($r eq 'SCALAR') { @ret = (@ret, ($$a)); }
		elsif ($r eq 'ARRAY')  { @ret = (@ret, @$a);  }
		else {
			print "Unknown ref ".$r."\n";
		}
	}
	return \@ret;
}

# Normalize the spaces
sub normalize {
	my ($str) = @_;
	return '' if ($str eq '');
	$str =~ s/\t/ /g;
	$str =~ s/\s+/ /g;
	$str =~ s/(^\s*)|(\s*$)//g;
	$str =~ s/,//g;
	chomp($str);
	return $str;
}

# Get the content of a file
sub filegetcontents {
	my $file = shift || return '';
	my $fh;
	my $content = '';
	open($fh, "<", $file) || return;
	{
		local $/ = undef;
		$content = <$fh>;
	}
	close($fh);
	return $content;
}
# Set the content of a file
sub fileputcontents {
	my $file = shift || return;
	my $data = shift || return;
	my $fh;
	open($fh, '>', $file);
	print($fh $data);
	close($fh);

	return 1;
}


sub liststring2list {
	my @list;

	# Each element in the array
	foreach my $elem  (@{$_[0]}) {
		push(@list, @{string2list($elem)});
	}
	return \@list;
}

sub string2list {
	my ($elem) = @_;
	my @list;
	# Each listing
	foreach my $unit (split(/,/, $elem)) {
		# Each range in listing (if any)
		if (index($unit,'-') > -1) {
			my ($from,$to) = split(/-/, $unit);
			if ($from < 0 || !$to || $from > $to) {
				print "Invalid range: $unit";
				next;
			}
			push(@list, $from..$to);
		}
		# Simple listing (may be string)
		else {
			push(@list, $unit);
		}
	}
	return \@list;
}

sub check_listinvalid {

	my @ret;
	# Check if all element is a number
	if (! (join(',', @_) =~ /^([0-9]+|ALL)(,[,0-9]+)*$/)) {
		foreach my $var (@_) {
			if (! ($var =~ /^[0-9]+$/)) {
				push(@ret, $var);
			}
		}
	}

	return \@ret;
}


sub sched_dynload {
	eval "use Linux::CPUAffinity";
	if ($@) {
		return;
	}
	return 1;
}

sub sched_checkproc {
	open my $fh, '<', "/proc/self/status" or return;
	while (my $line = <$fh>) {
		if ($line =~ /^Cpus_allowed:/) {
			return 1;
		}
	}
	return;
}

# ######################################################### 
# CPU Management
#

sub cpu_dispmask_unknown {
	my ($cpu_show_mask) = @_;
	my $str = '';


	my @cpu_list = @{$cpu_show_mask->toList()};

	# Track cpuid to get isolated CPUs
	my $cpuid = 0;
	# Loop on all available CPUs to keep CPUID in sync
	foreach my $cpuid (@cpu_list) {

		$str .= " " if ($cpuid >= 100);
		$str .= " ??";
	}
	return $str;
}

# Display the CPU Masks in a visible way
sub cpu_dispmask {
	my ($cpu_show_mask, $affinity_mask) = @_;
	my $str = '';


	my @cpu_list = @{$cpu_show_mask->toList()};

	# Track cpuid to get isolated CPUs
	my $cpuid = 0;
	# Loop on all available CPUs to keep CPUID in sync
	foreach my $cpuid (@cpu_list) {

		$str .= " " if ($cpuid >= 100);

		# If CPU is isolated
		if ($cpu_isolated_mask->isBitSet($cpuid) ) {
			$str .= (($affinity_mask->isBitSet($cpuid)) ? " $chr_cpuisolon " : " $chr_cpuisoloff ");
		}
		else {
			$str .= (($affinity_mask->isBitSet($cpuid)) ? " $chr_cpustdon " : " $chr_cpustdoff ");
		}
	}
	return $str;
}

# List all avaialble CPUs
sub cpu_getavail {
	my @cpus;
	my $cpuinfo;
	# TODO: replace this by Linux::CPUAffinity->num_processors
	#       or fallback to /sys/devices/system/cpu/online
#return [0..127];
	open($cpuinfo, "<", "/proc/cpuinfo");
	while (<$cpuinfo>) {
		if (/^processor.+: ([0-9]+)$/) {
			push(@cpus,int($1));
		}
	}
	close($cpuinfo);
	return \@cpus;
}

sub cpu_getisolated {
	my @cpus;

	# TODO: Check for /sys/devices/system/cpu/isolated instead
	my $cmd = filegetcontents('/proc/cmdline');
	if (my ($res) = $cmd=~m/isolcpus=([0-9,-]+)/g) {
		my @isolated = @{string2list($res)};
		foreach my $cpu (@{cpu_getavail()}) {
			push(@cpus, $cpu) if (inarray($cpu, @isolated));
		}
	}
	return \@cpus;

}

sub cpu_getdefault {
	my @cpusdef;
	my @cpusisol = @{cpu_getisolated()};

	foreach my $cpu (@{cpu_getavail()}) {
		push(@cpusdef, $cpu) if (!inarray($cpu, @cpusisol));
	}
	return \@cpusdef;
}

sub cpu_gettopology {
	
	my %topo = (
		nodes    => [],
		#sockets  => [],
		#cores    => [],
		cpus     => [],

		#pkg2skt  => [],
		#skt2pkg  => [],

		#pkg2core => [],
		#core2pkg => [],

		#cpu2core => [],
		#core2cpu => [],

		# NUMA node
		cpu2node => [],
		node2cpu => [],
	);

	# List NUMA nodes
	my $nodesstr = filegetcontents("/sys/devices/system/node/online");
	@{$topo{nodes}} = @{string2list($nodesstr)};
	for my $node (@{$topo{nodes}}) {
		$node = normalize($node);
		# Seems /cpumap is a bitmask
		my $cpustr = filegetcontents("/sys/devices/system/node/node${node}/cpulist");
		my @list = @{string2list($cpustr)};
		$topo{node2cpu}[$node] = @list;
		foreach my $cpu (@list) {
			$topo{cpu2node}[$cpu] = $node;
		}
	}

	# Check for NUMA distance / physical cores

	return \%topo;
}

# #########################################################
# IRQ Management
#
sub irq_available_read {
	return (-r "/proc/irq/default_smp_affinity");
}
sub irq_available_write {
	return (-w "/proc/irq/default_smp_affinity");
}

sub irq_default {
	return Bitmask->new(filegetcontents("/proc/irq/default_smp_affinity"));
}

sub irq_list {
	my %irqs;
	my $irqinfo;

	# Parse the /proc/interrupts listing
	open($irqinfo, "<", "/proc/interrupts");
	my $regex = "^([0-9 ]+):([0-9 ]+) +(.+)";
	while (<$irqinfo>) {
		# If the line matches a valid entry
		if (/$regex/) {
			# Get the real IRQ affinity
			my $irqnum = int(normalize($1));

			# and add all the data to the listing
			$irqs{$irqnum} = {
				irq      => $irqnum,
				intr     => [split(" ", normalize($2))],
				name     => normalize($3),
				node     => normalize(filegetcontents("/proc/irq/$irqnum/node")),
				affinity => irq_getaffinity($irqnum) || 0,
			};
		}
	}
	close($irqinfo);
	return \%irqs;
}

sub irq_getaffinity {
	my ($irq) = @_;

	my $txt = filegetcontents("/proc/irq/$irq/smp_affinity") || return;
	return Bitmask->new($txt);
}

sub irq_setaffinity {
	my ($irq, $cpumask) = @_;
	my $file = "/proc/irq/$irq/smp_affinity";

	my $cpumaskstr = $cpumask->toHexStr();

	fileputcontents($file, $cpumaskstr);
	return ($cpumask->isEqual(irq_getaffinity($irq)));
}


# ######################################################### 
# Process management
# 

sub proc_available {
	return 1 if ($lib_sched);
	return 1 if ($has_proclist);
	return (defined findbin('taskset'));
}

sub proc_list {
	my (@pids) = @_;

	# I could parse /proc/*/task/*  but ps is standard and does it for us...
	# By default, select all of them
	my $pssel = (@pids) ? "-p ".join(' ', @pids) : 'ax';

	my $psversion = `ps -V|awk '{split(\$NF,a,"."); print a[1]"."a[2];}'`;
	if (0.0 + $psversion >= 3.3) {
		$has_ps_etimes = 1;
	}

	my @procs;
	# ilibc6 sets max username size to 32
	# pthread sets thread name max to 16
	my @fields = qw(tid pid ppid user:32 class rtprio nice psr pcpu pmem s comm:16);
	push(@fields, "etimes") if ($has_ps_etimes);

	# args *must* be last and will not be normalized
	push(@fields, "args");

	my $pscmd = "ps -L -o ".join("=,", @fields)."= $pssel";
	my $proc;
	open($proc, "-|", $pscmd);
	# Parse each line of ps
	while (<$proc>) {
		$_ = normalize($_);
		my @data = split(/\s+/);
		my %tmpdata;

		# Create the end array according the fields we requested in ps
		# The last argument will take all remaining output (args mostly)
		for my $i (0 .. ($#fields-1)) {
			# Remove the potential ":colsize" for ps output
			my $field = (split(/:/,$fields[$i]))[0];
			$tmpdata{$field} = normalize($data[$i]);
		}
		splice(@data, 0, $#fields);
		(@{$tmpdata{args}}) = @data;

		push(@procs, \%tmpdata);
	}
	close($proc);
	return \@procs;
}

sub proc_getaffinity {
	my $pid = shift;

	my @sched_cpus;

	# Use Perl internal scheduling lib if available
	if ($lib_sched && eval '@sched_cpus = @{Linux::CPUAffinity->get($pid)}' ) {
		return Bitmask->new(\@sched_cpus);
	}
	# Check if the value is available in /proc/$pid/
	# Yes, works also for non-leader threads, no need to /proc/$pid/task/$tid
	elsif ($has_proclist && open my $fh, '<', "/proc/$pid/status") {
		while (my $line = <$fh>) {
			if ( my ($mask_str) = $line =~ m/^Cpus_allowed:\s+([0-9a-fA-F,]+)/) {
				#$mask_str = "abcdffff,ffffffff,11111111,ffffffff";
				close ($fh);

				my $r = $cpu_allavail_mask->getIntersectMask($mask_str);
				return $r;
			}
		}
		close($fh);
	}
	# Fallback to spawn a taskset process (slow)
	else {
		my (@out) = split(/\s+/, qx($bin_taskset -p $pid 2>/dev/null));

		# If the process isnt visible or already gone
		return if !@out;
		return pop(@out);
	}
}

sub proc_setaffinity {
	my ($pid, $affinity_mask) = @_;

	my $newaff_mask;

	if ($lib_sched) {
		# set
		Linux::CPUAffinity->set( $pid => [$affinity_mask->toList()] );
		# check
		$newaff_mask = Bitmask->new(\@{Linux::CPUAffinity->get($pid)});
	}
	else {
		# Set
		my $affinitystr = $affinity_mask->toString();
		my (@out) = split(/\s+/, qx($bin_taskset --pid $affinitystr $pid 2>/dev/null));
		# Check
		my $newaff_str = pop(@out);
		$newaff_mask = Bitmask->new(\@{string2list($newaff_str)});
	}

	# Validate
	return ($affinity_mask->isEqual($newaff_mask)) ;
}


# =============================================================================
#  Bitmask helper package
# =============================================================================

package Bitmask;

no warnings 'portable';  # Support for 64-bit ints required

use Storable qw(dclone);
use Data::Dumper;
use Config;
# ivsize = 4 (32) or 8 (64)
use constant INTSIZE => 8 * $Config{ivsize};
# Can be fetched from /sys/devices/system/cpu/kernrel_max / offline (?)
use constant MAXCPUS => 256;
# 1 char = 4 bits
use constant NCHARPERINT => INTSIZE / 4;
use constant GRPMAX  => MAXCPUS / INTSIZE;

# Features:
# Creation from: Hex Str, List
# Output to: Hex Str, List
# Compute: Return 2 mask intersections
# Set: bit from position (list) or number (or) or mask (and)

# -----------------------------------------------------------------------------
# Create new instance
# -----------------------------------------------------------------------------

sub new {
	my ($class, $input) = @_;

	# 8 * 64 bits groups int, => up to 512 CPUs
	my $self = {
		numGrps     => [],
		grpMax      => 0,
	};

	for (my $g=0; $g<GRPMAX; $g++) {
		$self->{numGrps}[$g] = 0;
	}

	# Simple scalar: Expect hex string
	if (ref($input) eq "") {
		# Remove non-hex chars (mostly separators like ,)
		$input =~ s/[^0-9a-fA-F]//g;
		# Reverse the string for substr ease
		my $str = reverse($input);
		my $smax = length($str);

		for (my $g=0, my $s=0; $g<GRPMAX && $s<=$smax; $g++, $s+=NCHARPERINT) {
			# Reverse again the extract number
			$self->{numGrps}[$g] = hex(reverse(substr($str, $s, NCHARPERINT)));
			$self->{grpMax} = $g;
		}
	}
	# List of values
	elsif (ref($input) eq "ARRAY") {
		foreach my $elem (@$input) {
			my $grpId = int($elem / INTSIZE);
			$self->{numGrps}[$grpId] |= 1 << ($elem - $grpId * INTSIZE);
			$self->{grpMax} = $grpId if ($grpId > $self->{grpMax});
		}
	}
	else {
		die("Invalid input data for Bitmask: '$input' (type:".ref($input).")");
	}

	bless $self, $class;
	return $self;
}

# -----------------------------------------------------------------------------
#  Output
# -----------------------------------------------------------------------------

#
# Output Hex String
#
sub toHexStr {
	my ($self) = @_;
	my $str = '';
	for (my $i=$self->{grpMax}; $i>=0; $i--) {
		$str .= sprintf("%x", $self->{numGrps}[$i]);
		$str .= ',' if ($i>0);
	}

	return $str;
}

#
# Output List
#
sub toList {
	my ($self) = @_;
	my @list;
	for (my $g=0; $g<=$self->{grpMax}; $g++) {
		my $n = $self->{numGrps}[$g];
		for (my $i=0; $i<INTSIZE && $n > 0; $i++) {
			push(@list, $i + ($g * INTSIZE)) if ( $n & 1);
			$n >>= 1;
		}
	}
	return \@list;
}

sub getIntersectMask {
	my ($self, $obj) = @_;

	# Deep-clone
	my $ret = dclone($self);


	# Parsing against another bitmask
	if (ref($obj) eq "Bitmask") {
		for (my $g=0; $g<=$self->{grpMax}; $g++) {
			$ret->{numGrps}[$g] &= $obj->{numGrps}[$g];
		}
	}
	# Parsing against a scalar
	elsif (ref($obj) eq "") {
		$obj =~ s/[^0-9a-fA-F]//g;
		my $str = reverse($obj);
		my $smax = length($str);

		my $g = 0;
		for ($g=0, my $s=0; $g<=$ret->{grpMax} && $s<=$smax; $g++, $s+=NCHARPERINT) {
			$ret->{numGrps}[$g] &= hex(reverse(substr($str, $s, NCHARPERINT)));
		}
		$ret->{grpMax} = $g;
	}
	else {
		print "Fatal: Unhandled Bitmask Intersection resquested: '".ref($obj)."'\n";
		exit(1);
	}
	return $ret;
}


# -----------------------------------------------------------------------------
# Tests of bitmask
# -----------------------------------------------------------------------------

sub isBitSet {
	my ($self, $pos) = @_;
	# Fast check to avoid a div
	if ($pos < INTSIZE) {
		return 2**$pos & $self->{numGrps}[0];
	}
	# Bigger than a standard int, need a div
	else {
		# Quick check: our max group is lower than requested position
		return 0 if ($pos > ($self->{grpMax} * INTSIZE) );
		my $g = int($pos/INTSIZE);
		return (2**($pos - ($g*INTSIZE))) & $self->{numGrps}[$g];
	}
}

sub isEqual {
	my ($self, $mask) = @_;
	for (my $g=0; $g<GRPMAX; $g++) {
		return 0 if ($mask->{numGrps}[$g] ne $self->{numGrps}[$g])
	}
	return 1;
}

sub isIntersect {
	my ($self, $mask) = @_;
	for (my $g=0; $g<GRPMAX; $g++) {
		return 1 if ($mask->{numGrps}[$g] & $self->{numGrps}[$g]);
	}
	return 0;
}

# -----------------------------------------------------------------------------
#
# -----------------------------------------------------------------------------

__END__
=head1 NAME

smp_affinity - Get and Set the affinity of IRQs and Processes

=head1 SYNOPSIS

smp_affinity [-ksdh] [--nocolor] [-i IRQs] [-p PIDs ] [[-I IRQs|-P PIDs] -C CPUs]

 Options:
  -i|--show-irq LIST   Show interrupts with IRQ number in LIST
  -p|--show-proc LIST  Show process with PID in LIST
  -c|--show-cpus LIST  Filter on the CPUs list to display
  -s|--statistics      Show statistics (%cpu,%mem,sched,state) for process or
                       show interrupt count for IRQs
     --nocolor         Don't use colored output (auto-selected if not a tty)
  -k|--kernel-threads  Show kernel threads
  -d|--defined-only    Only show tasks/irqs with non-standard affinity

  -I|--set-irq LIST    Set the affinity of interrupt in LIST to CPUs listed by -C
  -P|--set-proc LIST   Set the affinity of processes in LIST to CPUs listed by -C
  -C|--set-proc LIST   Set LIST of CPUs on which to bind given processes or interrupts

  --pctcpu=[-]<0-99>   Select only process that consumes more (or less if prefixed
                       by -) than the specified percentage of CPU
  --pctmem=[-]<0-99>   Select only process that consumes more (or less if prefixed
                       by -) than the specified percentage of RAM

  LIST can be a combination of list and sequences of numbers, or keyword 'ALL':
    1,2,3,4              Explicit listing
    1-4                  Sequence, equivalent to the previous list
    1,2,3,4,6,10,11,12   Explicit listing
    1-4,6,10-12          Combined sequence + listing, same as previous list
    ALL                  Special keyword to match all

  CPUs lists can also have special keywords:
    ISOLATED             All isolated cores
    NOTISOLATED          Non-isolated cores

=head1 EXAMPLES

