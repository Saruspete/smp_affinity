#!/usr/bin/perl

# #############################################################################
# smp_affinity.pl - Utility to get/set affinities of IRQs and Processes
#
# - Display CPU affinity for IRQ & Processes
# - Set distributed patterns from keywords
#
# Author : Adrien Mahieux <adrien.mahieux@gmail.com>
#
# #############################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# #############################################################################

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case gnu_compat bundling auto_help);
use Pod::Usage;
use List::Util qw(max);

# One day at work, they asked me to install & prepare a Ryzen Epyc 2*32 cores..
# well, a bitmap with 2^64 is a bit large. Thats 128 if SMT activated...
# In /proc/irq/default_smp_affinity, it's shown as  8 * 64bits, let it be:
# 1157920892373161954235709850086879078532699846656405640394575840079131296399350
# Size is done by include/linux/bitops.h :
#   => BITS_TO_LONGS (nb_cpu)
#   => DIV_ROUND_UP (nb_cpu, NBITS_PER_BYTE * sizeof(long))
# TODO: Require Math::BigInt only if necessary
use Math::BigInt;

my $opt_show_help;
my $opt_show_sep = ' ';

my $opt_show_onlymod;
my $opt_show_onlydef;
my $opt_show_pctcpu;
my $opt_show_pctmem;
my $opt_show_realtime;
my $opt_show_stats;
my $opt_show_kthreads;
my $opt_show_quiet;
my $opt_show_count;
# TODO: Add filtering
my $opt_show_filter;

my @opt_show_listcpu;
my @opt_show_listirq;
my @opt_show_listproc;
my @opt_show_listuser;

my $opt_set_dry;
my @opt_set_listcpu;
my @opt_set_listirq;
my @opt_set_listproc;
my $opt_set_distribute;

my $bin_taskset = findbin('taskset');
my $lib_sched = sched_dynload();
my $has_proclist = sched_checkproc();
my $chk_userlisthasregex = 0;
my $has_color = (-t STDOUT) ? 1 : 0;
my @cpu_isolatedlist = @{cpu_getisolated()};
my $cpu_isolatedmask = list2mask(\@cpu_isolatedlist);
my @cpu_schedrt = ['FF','RR'];

# Parse options
GetOptions(
	# Help
	'h|help'            => \$opt_show_help,

	# Display format modifiers
	's|statistics'      => \$opt_show_stats,
	'q|quiet'           => \$opt_show_quiet,
	'c|show-cpus=s'     => \@opt_show_listcpu,
	'color!'            => \$has_color,

	# Display filters
	'd|defined-only'    => \$opt_show_onlydef,
	'k|kernel-threads'  => \$opt_show_kthreads,
	'pctcpu=s'          => \$opt_show_pctcpu,
	'pctmem=s'          => \$opt_show_pctmem,
	'rt|realtime'       => \$opt_show_realtime,
	#'f|filter=s'        => \$opt_show_filter,
	'r|show-count=s'    => \$opt_show_count,
	'i|show-irq=s'      => \@opt_show_listirq,
	'p|show-proc=s'     => \@opt_show_listproc,
	'u|show-user=s'     => \@opt_show_listuser,

	# Set related options
	'm|show-modified'   => \$opt_show_onlymod,
	'dry|pretend'       => \$opt_set_dry,

	# Setting values
	'C|set-cpu=s'       => \@opt_set_listcpu,
	'I|set-irq=s'       => \@opt_set_listirq,
	'P|set-proc=s'      => \@opt_set_listproc,
	'D|distribute=i'    => \$opt_set_distribute,
) or die ('Error while parsing options. Stopping');

pod2usage(-verbose=>2) if $opt_show_help;


my $chr_cpustdon   = "X";
my $chr_cpustdoff  = " ";
my $chr_cpuisolon  = "I";
my $chr_cpuisoloff = " ";

# Use red background to display isolated cores
if ($has_color) {
	$chr_cpuisolon  = "\e[41;1m" . $chr_cpuisolon  . "\e[0m";
	$chr_cpuisoloff = "\e[41;1m" . $chr_cpuisoloff . "\e[0m";
}
# If no color, most likely batch mode, thus provide fixed line length (no space)
else {
	$chr_cpuisoloff = "-";
	$chr_cpustdoff  = ".";
}

# #############################################################################
#
# Main processing
#
# #############################################################################

#
# Pre-checks and command line parsing
#

if (@opt_show_listirq || @opt_set_listirq) {
	if ( !irq_available() ) {
		print "IRQs management is not available. Are you root ?\n";
		exit(1);
	}
	@opt_show_listirq = @{liststring2list(\@opt_show_listirq)};
	@opt_set_listirq  = @{liststring2list(\@opt_set_listirq)};
}


#
# Processes listing
#
if (@opt_show_listproc || @opt_set_listproc) {
	if ( !proc_available() ) {
		print "The Process management is not available\n";
		print "Be sure the program 'taskset' is installed on this system\n";
		exit(1);
	}

	@opt_show_listproc  = @{liststring2list(\@opt_show_listproc)};
	@opt_set_listproc   = @{liststring2list(\@opt_set_listproc)};
}

if (@opt_set_listirq || @opt_set_listproc) {
	if (!@opt_set_listcpu) {
		print "You must specify a list of CPUs to set (-C <cpu-list>)\n";
		exit(1);
	}
}

if ($opt_show_onlymod && (@opt_show_listproc || @opt_show_listirq || @opt_show_listuser || $opt_show_filter || $opt_show_count ) ) {
	print "You can't mix 'show-modified|m' with other filters (-d,-p,-i,-u,-c)\n";
	exit(1);
}

foreach my $user (@opt_show_listuser) {
	# If user has non standard chars, assume a regex
	if (! ($user =~ /^[^a-zA-Z0-9_]+$/)) {
		$chk_userlisthasregex = 1;
	}
}

# Only apply show defaults if no set action is requested
if (!@opt_set_listirq  && !@opt_set_listproc &&
    !@opt_show_listirq && !@opt_show_listproc) {
	# Defaults to all process to display
	if (!@opt_show_listproc) {
		@opt_show_listproc = 'ALL';
	}
}

# Defaults to all CPUs to display
if (!@opt_show_listcpu) {
	@opt_show_listcpu = @{cpu_list()};
}

# Do standard expansion
@opt_set_listcpu   = @{liststring2list(\@opt_set_listcpu)};
@opt_show_listcpu  = @{liststring2list(\@opt_show_listcpu)};

# Replace special values by their real listing
@opt_set_listcpu   = @{cpu_list()}        if (inarray('ALL', @opt_set_listcpu));
@opt_show_listcpu  = @{cpu_list()}        if (inarray('ALL', @opt_show_listcpu));
@opt_set_listcpu   = @cpu_isolatedlist    if (inarray('ISOLATED', @opt_set_listcpu));
@opt_show_listcpu  = @cpu_isolatedlist    if (inarray('ISOLATED', @opt_show_listcpu));
@opt_set_listcpu   = @{cpu_getdefault()}  if (inarray('NOTISOLATED', @opt_set_listcpu));
@opt_show_listcpu  = @{cpu_getdefault()}  if (inarray('NOTISOLATED', @opt_show_listcpu));


# Check if all values were correctly expanded
my %checkvars = (
	'-c|--show-cpu'  => \@opt_show_listcpu,
	'-p|--show-proc' => \@opt_show_listproc,
	'-i|--show-irq'  => \@opt_show_listirq,
	'-C|--set-cpu'   => \@opt_set_listcpu,
	'-P|--set-proc'  => \@opt_set_listproc,
	'-I|--set-irq'   => \@opt_set_listirq,
);
my $chk_haserr = 0;
for my $chkopt (keys %checkvars) {
	my $chkvar = $checkvars{$chkopt};
	my @invalid = @{check_listinvalid(@$chkvar)};
	if (@invalid) {
		print("Error: Invalid value(s) for $chkopt: " . join(', ', @invalid)."\n");
		$chk_haserr++;
	}
}
exit(1) if $chk_haserr;

#@opt_set_listproc  = @{proc_getaffinitized()} if (inarray('NONSTANDARD', @opt_set_listproc));
#@opt_show_listproc = @{proc_getaffinitized()} if (inarray('NONSTANDARD', @opt_show_listproc));


# #########################################################
# Set requested values
#

# Reset the display lists when displaying only modified elements
if ($opt_show_onlymod) {
	@opt_show_listproc = ();
	@opt_show_listirq = ();
}
# IRQs
if (@opt_set_listirq) {
	foreach my $irq (@opt_set_listirq) {
		# Pretend to change...
		if ($opt_set_dry) {
			# Add to display list only if showing modified
			if ($opt_show_onlymod && irq_getaffinity($irq) ne list2mask(\@opt_set_listcpu)) {
				push(@opt_show_listirq, $irq);
			}
		}
		# Set if not pretending
		else {
			irq_setaffinity($irq, \@opt_set_listcpu);
		}
	}
}

# Processes
if (@opt_set_listproc) {

	# Replace the keyword 'ALL' by PID list
	if (inarray('ALL', @opt_set_listproc)) {
		@opt_set_listproc = map { $_->{tid} } @{proc_list()};
	}

	foreach my $pid (@opt_set_listproc) {

		# Add to display list only if showing modified
		if ($opt_show_onlymod && proc_getaffinity($pid) ne list2mask(\@opt_set_listcpu)) {
			push(@opt_show_listproc, $pid);
			push(@opt_show_listcpu, @opt_set_listcpu);
		}

		# Pretend to change
		my $chgstr = "affinity '".join(',', @opt_set_listcpu)."' to PID '$pid'";
		if ($opt_set_dry) {
			print "Would have set $chgstr\n";
		}
		# Set if not pretending
		else {
			print "Setting $chgstr\n";
			proc_setaffinity($pid, \@opt_set_listcpu);
		}
	}
}


# #########################################################
# Display
#

# Get some variables
my $term_size = int(qx(/usr/bin/tput cols)) || 80;


my @cpu_list = @opt_show_listcpu;
my $cpu_count = $#cpu_list+1;

my $cpu_mask_show = list2mask(\@opt_show_listcpu);
my $cpu_mask_sys = list2mask(cpu_list());

my $proc_default = list2mask(cpu_getdefault());

# Calculations for column sizes
my $col_sep = ' ';
my $col_id  = 6;
my $col_name = 8;
my $col_cpu = $cpu_count * 3; # 3 cols / cpu

# dyn column = term width -  1st col  - 2nd col     - last col   - 3 cols * 1 char separator
my $col_text = $term_size - ($col_id) - ($col_name) - ($col_cpu) - (3*1) -1;

if ($col_text <= 0) {
	print "Your terminal is not wide enough to display the list for $cpu_count CPUs\n";
	print "You're missing ".abs($col_text)." columns\n";
	exit(1);
}

# lines formaters
#my $head = "%-".($col_id+1+$col_name+1+$col_text+1)."s ";
my $head =	"%-${col_id}s"    . $col_sep .
			"%-${col_name}s"  . $col_sep .
			"%-${col_text}s " . $col_sep;

my $body =	"%-${col_id}.${col_id}s"     . $col_sep .
			"%-${col_name}.${col_name}s" . $col_sep .
			"%-${col_text}.${col_text}s" . $col_sep .
			" %s";


# Show the header if not quiet
if (!$opt_show_quiet && (@opt_show_listproc || @opt_show_listirq) ) {
	# Print the header
	printf($head, "ID", "Owner", "Description");
	foreach my $cpu (@cpu_list) {
		print(" ") if ($cpu <= 9);
		print("$cpu ");
	}
	print "\n";
}


# Display IRQs
if (@opt_show_listirq) {

	my $irq_default = irq_default();
	foreach my $irq (@{irq_list()}) {

		# Filter on non-stnadard affinities only
		next if ($opt_show_onlydef && $irq->{affinity} eq $irq_default );


		# Filter
		if (inarray('ALL', @opt_show_listirq) || inarray($irq->{irq}, @opt_show_listirq)) {


			# Specific CPU affinity
			if ($cpu_mask_show ne $proc_default) {
				next if (! ( $irq->{affinity} & $cpu_mask_show) );
			}


			my $text = $irq->{name};

			if ($opt_show_stats) {
				$text .= "";
			}

			printf($body."\n",
					$irq->{irq},
					'',
					$text,
					cpu_dispmask(\@opt_show_listcpu, $irq->{affinity})
				);
		}
	}
}

# Display CPUs
if (@opt_show_listproc) {

	# Order the process list - I bet you love Schwartzian transform :)
	my @proclist =
		map { $_->[2] }
		sort { $a->[1] <=> $b->[1] || $a->[0] <=> $b->[0] }
		map { [int($_->{pid}), (int($_->{ppid}||0) eq 2)? 0 : ($_->{ppid}||0), $_] }
		@{proc_list()};

	# Walk on each process
	proclist:
	foreach my $proc (@proclist) {

		# Filter on simple user listing
		if (!$chk_userlisthasregex) {
			next if (@opt_show_listuser && ! inarray($proc->{user}, @opt_show_listuser));
		}
		# listing has non standard chars, advanced parsing
		else {
			# List all users.
			# - If we match a negated pattern, skip it directly
			# - If we found at least one non-negated listing, expect user to be listed
			# - If we have only negated patterns, allow all

			# By default, expect no direct listing so allow user
			my $usermustbefound = 0;
			my $userfound = 0;
			foreach my $useralias (@opt_show_listuser) {
				# Need to do a copy, else we modify the source from array
				my $user = $useralias;

				# Negation handling
				my $skiponmatch = 0;
				if (substr($user, 0, 1) eq "!") {
					$user = substr($user, 1);
					$skiponmatch = 1;
				}
				# We have at least one explicit listing (non negated)
				else {
					$usermustbefound = 1;
				}

				# We got a match !
				if ($proc->{user} =~ /^$user$/) {
					# If user matches a negated user, skip it directly
					if ($skiponmatch) {
						next proclist;
					# Mark it as good for now
					}
					else {
						$userfound = 1;
					}
				}
			}

			# skip if we didn't find a match when we should have
			next proclist if (!$userfound && $usermustbefound);
		}

		# Filter on kernel thread (PID: 1=init, 2=kthreadd)
		next if (!$opt_show_kthreads && ($proc->{pid} eq 2 || $proc->{ppid} eq 2));

		if (inarray('ALL', @opt_show_listproc) ||
			inarray($proc->{tid}, @opt_show_listproc) ||
			inarray($proc->{pid}, @opt_show_listproc) ) {

			# Skip elements where we don't have affinity
			my $affinity = proc_getaffinity($proc->{tid}) || next;

			# Filter on non-stnadard affinities only
			if ($opt_show_onlydef) {

				# Default CPU listing
				next if ($affinity eq $proc_default);

				# Specific CPU affinity
				if ($cpu_mask_show ne $proc_default) {
					next if (! ( $affinity & $cpu_mask_show) );
				}
			}

			# Filter by cpu affinity count
			if ($opt_show_count) {
				my $rangeDir = substr($opt_show_count, 0, 1);
				# Less / More / Exactly
				next if ($rangeDir eq '-' && $affinity > substr($opt_show_count, 1));
				next if ($rangeDir eq '+' && $affinity < substr($opt_show_count, 1));
				next if (int($opt_show_count) eq $opt_show_count && $affinity != $opt_show_count);
			}

			# Filter by CPU Usage
			if ($opt_show_pctcpu) {
				my $cpuVal = int($opt_show_pctcpu);
				next if ($cpuVal < 0) && int($proc->{pcpu}) > -$cpuVal;
				next if ($cpuVal >= 0) && int($proc->{pcpu}) < $cpuVal;
			}
			# Filter by memory Usage
			if ($opt_show_pctmem) {
				my $memVal = int($opt_show_pctmem);
				next if ($memVal < 0) && int($proc->{pmem}) > -$memVal;
				next if ($memVal >= 0) && int($proc->{pmem}) < $memVal;
			}
			# Filter by realtime
			if ($opt_show_realtime) {
				next if (!inarray($proc->{class}, @cpu_schedrt));
			}

			my $text = join(' ', @{$proc->{args}});
			# If it's not the thread leader, offset it and change the text
			if (($proc->{tid} != $proc->{pid})) {
				$text = '    ' . $proc->{comm};
			}

			# Add more statistics before
			if ($opt_show_stats) {
				$text = sprintf("%-3s %-2s %-4s %-4s %-1s", $proc->{class}, $proc->{rtprio} || "-", $proc->{pcpu}, $proc->{pmem}, $proc->{s})." $text";
			}

			# Finally, display
			printf($body."\n",
					$proc->{tid},
					$proc->{user},
					$text,
					cpu_dispmask(\@opt_show_listcpu, $affinity),
				);
		}
	}
}




# #############################################################################
#
# Working subs : The magic happens here
#
# #############################################################################


# Find a binary in $ENV{PATH} and usual paths
sub findbin {
	my $cmd = shift;
	my @paths = split(/:/, $ENV{PATH});
	push(@paths, ('/sbin','/usr/sbin'));
	foreach my $path (@paths) {
		my $b = $path.'/'.$cmd;
		return $b if (-x $b);
	}
	return;
}

# Is an element in an array
sub inarray {
	my $match = shift;
	grep $_ eq $match, @_;
}

sub arrayize {
	my @arrays = @_;
	my @ret;
	foreach $a (@arrays) {
		my $r = ref($a);

		# Scalar
		if ($r eq '') {          @ret = (@ret, ($a));  }
		# Refs
		elsif ($r eq 'SCALAR') { @ret = (@ret, ($$a)); }
		elsif ($r eq 'ARRAY')  { @ret = (@ret, @$a);  }
		else {
			print "Unknown ref ".$r."\n";
		}
	}
	return \@ret;
}

# Normalize the spaces
sub normalize {
	my ($str) = @_;
	return '' if (!$str);
	$str =~ s/\t/ /g;
	$str =~ s/\s+/ /g;
	$str =~ s/(^\s*)|(\s*$)//g;
	$str =~ s/,//g;
	chomp($str);
	return $str;
}

# Get the content of a file
sub filegetcontents {
	my $file = shift || return '';
	my $fh;
	my $content = '';
	open($fh, "<", $file);
	{
		local $/ = undef;
		$content = <$fh>;
	}
	close($fh);
	return $content;
}
# Set the content of a file
sub fileputcontents {
	my $file = shift || return;
	my $data = shift || return;
	my $fh;
	open($fh, '>', $file);
	print($fh $data);
	close($fh);

	return 1;
}


# Transform an array of IDs to a mask
sub list2mask {
	my $mask = 0;
	foreach my $cpu (@{$_[0]}) {
		$mask |= 1 << $cpu;
	}
	return $mask;
}

sub liststring2list {
	my @list;

	# Each element in the array
	foreach my $elem  (@{$_[0]}) {
		push(@list, @{string2list($elem)});
	}
	return \@list;
}

sub string2list {
	my ($elem) = @_;
	my @list;
	# Each listing
	foreach my $unit (split(/,/, $elem)) {
		# Each range in listing (if any)
		if (index($unit,'-') > -1) {
			my ($from,$to) = split(/-/, $unit);
			if ($from < 0 || !$to || $from > $to) {
				print "Invalid range: $unit";
				next;
			}
			push(@list, $from..$to);
		}
		# Simple listing (may be string)
		else {
			push(@list, $unit);
		}
	}
	return \@list;
}

sub check_listinvalid {

	my @ret;
	# Check if all element is a number
	if (! (join(',', @_) =~ /^([0-9]+|ALL)(,[,0-9]+)*$/)) {
		foreach my $var (@_) {
			if (! ($var =~ /^[0-9]+$/)) {
				push(@ret, $var);
			}
		}
	}

	return \@ret;
}


sub sched_dynload {
	eval "use Linux::CPUAffinity";
	if ($@) {
		return;
	}
	return 1;
}

sub sched_checkproc {
	open my $fh, '<', "/proc/self/status" or return;
	while (my $line = <$fh>) {
		if ($line =~ /^Cpus_allowed:/) {
			return 1;
		}
	}
	return;
}

# ######################################################### 
# CPU Management
#

# List all avaialble CPUs
sub cpu_list {
	my @cpus;
	my $cpuinfo;
	# TODO: replace this by Linux::CPUAffinity->num_processors
	#       or fallback to /sys/devices/system/cpu/online
	open($cpuinfo, "<", "/proc/cpuinfo");
	while (<$cpuinfo>) {
		if (/^processor.+: ([0-9]+)$/) {
			push(@cpus,int($1));
		}
	}
	close($cpuinfo);
	return \@cpus;
}

# Display the CPU Masks in a visible way
sub cpu_dispmask {
	my ($cpulist, $affinity) = @_;
	my $cpumask = list2mask($cpulist);
	my $str = '';

	# Track cpuid to get isolated CPUs
	my $cpuid = 0;
	my $cpumax = max(@$cpulist);
	my $bittest = 1;
	# Loop on all available CPUs to keep CPUID in sync
	while ($cpuid <= $cpumax) {

		# Filter on CPU to display
		if ($cpumask & $bittest) {

			# If CPU is isolated
			if ($cpu_isolatedmask & $bittest) {
				$str .= (($affinity & $bittest) ? " $chr_cpuisolon " : " $chr_cpuisoloff ");
			}
			else {
				$str .= (($affinity & $bittest) ? " $chr_cpustdon " : " $chr_cpustdoff ");
			}
		}

		$cpuid++;
		$bittest = $bittest << 1;
	}
	return $str;
}

sub cpu_getisolated {
	my @cpus;
	my $cmd = filegetcontents('/proc/cmdline');
	if (my ($res) = $cmd=~m/isolcpus=([0-9,-]+)/g) {
		my @isolated = @{string2list($res)};
		foreach my $cpu (@{cpu_list()}) {
			push(@cpus, $cpu) if (inarray($cpu, @isolated));
		}
	}
	return \@cpus;

}

sub cpu_getdefault {
	my @cpusdef;
	my @cpusisol = @{cpu_getisolated()};

	foreach my $cpu (@{cpu_list()}) {
		push(@cpusdef, $cpu) if (!inarray($cpu, @cpusisol));
	}
	return \@cpusdef;
}


# #########################################################
# IRQ Management
#
sub irq_available {
	return ($> == 0);
}

sub irq_default {
	my $str = normalize(filegetcontents("/proc/irq/default_smp_affinity"));
	my $dec = Math::BigInt->new("0x$str");
	return $dec;
}

sub irq_list {
	my @irqs;
	my $irqinfo;

	# Parse the /proc/interrupts listing
	open($irqinfo, "<", "/proc/interrupts");
	my $regex = "^([0-9 ]+):([0-9 ]+) +(.+)";
	while (<$irqinfo>) {
		# If the line matches a valid entry
		if (/$regex/) {
			# Get the real IRQ affinity
			my $irqnum = int(normalize($1));
			my $affinity = Math::BigInt->new(
				"0x".normalize(filegetcontents("/proc/irq/$irqnum/smp_affinity"))
			);

			# and add all the data to the listing
			push(@irqs,{
				irq      => $irqnum,
				intr     => [split(" ", normalize($2))],
				name     => normalize($3),
				affinity => $affinity,

			});
		}
	}
	close($irqinfo);
	return \@irqs;
}

sub irq_setaffinity {
	my ($irq, $cpulist) = @_;
	my $file = "/proc/irq/$irq/smp_affinity";
	my $cpumask = sprintf("%x", list2mask($cpulist));

	# Special case: cpu >= 32 needs to be split with ','
	my $len = length($cpumask);
	if ($len > 8) {
		# Treat as string: reverse the mask, and substr every 8 (or less remain)
		$cpumask = reverse($cpumask);
		my $cpumask2 = "";
		for (my $remain = $len; $remain > 0; $remain -= 8) {
			$cpumask2 .= substr($cpumask, $len-$remain, 8);
			# Don't put the "," for the first pass. Would fail
			if ($remain == $len) { $cpumask2 .= ","; }
		}
		$cpumask = reverse($cpumask2);
	}

	fileputcontents($file, $cpumask);
	return (filegetcontents($file) eq $cpumask);
}


# ######################################################### 
# Process management
# 

sub proc_available {
	return 1 if ($lib_sched);
	return 1 if ($has_proclist);
	return (defined findbin('taskset'));
}

sub proc_list {
	my (@pids) = @_;

	# I could parse /proc/*/task/*  but ps is standard and does it for us...
	# By default, select all of them
	my $pssel = (@pids) ? "-p ".join(' ', @pids) : 'ax';

	my @procs;
	# args *must* be last and will not be normalized
	# ilibc6 sets max username size to 32
	# pthread sets thread name max to 16
	my @fields = qw(tid pid ppid user:32 class rtprio nice pcpu pmem s comm:16 args);
	my $pscmd = "ps -L -o ".join("=,", @fields)."= $pssel";
	my $proc;
	open($proc, "-|", $pscmd);
	# Parse each line of ps
	while (<$proc>) {
		$_ = normalize($_);
		my @data = split(/\s+/);
		my %tmpdata;

		# Create the end array according the fields we requested in ps
		# The last argument will take all remaining output (args mostly)
		for my $i (0 .. ($#fields-1)) {
			# Remove the potential ":colsize" for ps output
			my $field = (split(/:/,$fields[$i]))[0];
			$tmpdata{$field} = normalize($data[$i]);
		}
		splice(@data, 0, $#fields);
		(@{$tmpdata{args}}) = @data;

		push(@procs, \%tmpdata);
	}
	close($proc);
	return \@procs;
}

sub proc_getaffinity {
	my $pid = shift;

	my @sched_cpus;

	# Use Perl internal scheduling lib if available
	if ($lib_sched && eval '@sched_cpus = @{Linux::CPUAffinity->get($pid)}' ) {
		return list2mask(\@sched_cpus);
	}
	# Check if the value is available in /proc/$pid/
	# Yes, works also for non-leader threads, no need to /proc/$pid/task/$tid
	elsif ($has_proclist && open my $fh, '<', "/proc/$pid/status") {
		while (my $line = <$fh>) {
			if ( my ($mask) = $line =~ m/^Cpus_allowed:\s+([0-9a-fA-F,]+)/) {
				close ($fh);
				return Math::BigInt->new("0x".normalize($mask)) & $cpu_mask_sys;
			}
		}
		close($fh);
	}
	# Fallback to spawn a taskset process (slow)
	else {
		my (@out) = split(/\s+/, qx($bin_taskset -p $pid 2>/dev/null));

		# If the process isnt visible or already gone
		return if !@out;

		# Return the mask if any
		return Math::BigInt->new(pop(@out));
	}
}

sub proc_setaffinity {
	my ($pid, $cpus) = @_;
	my $cpumask = sprintf("0x%x", list2mask($cpus));
	my (@out) = split(/\s+/, qx($bin_taskset -p $cpumask $pid 2>/dev/null));
	my $newaff = pop(@out);

	return ($newaff eq $cpumask) ;
}



__END__
=head1 NAME

smp_affinity - Get and Set the affinity of IRQs and Processes

=head1 SYNOPSIS

smp_affinity [-ksdh] [--nocolor] [-i IRQs] [-p PIDs ] [[-I IRQs|-P PIDs] -C CPUs]

 Options:
  -i|--show-irq LIST   Show interrupts with IRQ number in LIST
  -p|--show-proc LIST  Show process with PID in LIST
  -c|--show-cpus LIST  Filter on the CPUs list to display
  -s|--statistics      Show statistics (%cpu,%mem,sched,state) for process or
                       show interrupt count for IRQs
     --nocolor         Don't use colored output (auto-selected if not a tty)
  -k|--kernel-threads  Show kernel threads
  -d|--defined-only    Only show tasks/irqs with non-standard affinity

  -I|--set-irq LIST    Set the affinity of interrupt in LIST to CPUs listed by -C
  -P|--set-proc LIST   Set the affinity of processes in LIST to CPUs listed by -C
  -C|--set-proc LIST   Set LIST of CPUs on which to bind given processes or interrupts

  LIST can be a combination of list and sequences of numbers, or keyword 'ALL':
    1,2,3,4              Explicit listing
    1-4                  Sequence, equivalent to the previous list
    1,2,3,4,6,10,11,12   Explicit listing
    1-4,6,10-12          Combined sequence + listing, same as previous list
    ALL                  Special keyword to match all

  CPUs lists can also have special keywords:
    ISOLATED             All isolated cores
    NOTISOLATED          Non-isolated cores

=head1 EXAMPLES

